<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>
<script>
    // Promise 的含义
    // 基本用法
    Promise.prototype.then()
    Promise.prototype.catch()
    Promise.prototype.finally()
    Promise.all()
    Promise.race()
    Promise.allSettled()

    //对象的状态不受外界影响。 它代表着一个异步操作
    //状态分为三种 pending（进行中）、fulfilled（已成功）和rejected（已失败）
    //ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。
    const p1 = new Promise((resolve, reject) => {
        //do code
        if (success) {
            resolve(res)
        } else {
            reject(err)
        }
    })
    //Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。
    //resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），
    // 在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；
    //reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），
    //在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。
    // Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。
    p.then((res) => {
        // success
    }), function (err) {
        // err
    }

    function timer(ms) {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, ms, 'done');   //这里的‘done’是给前面的resolve传递的一个参数 setTimeout的第三个参数作用
        })
    }
    timer(100).then((res) => {
        console.log(res)  //done
    })

    // Promise 新建后就会立即执行。
    let p = new Promise((resolve, reject) => {
        console.log("Promise--2")
        resolve()
    })
    p.then(() => {
        console.log('promise123')
    })
    console.log("ppp--111")
    // Promise--2
    // index.html: 55 ppp--111
    // index.html: 53 promise123
    //新建的promise会立刻执行 then方法回调里面的内容 需要等待当前同步进行的线程执行完毕 然后执行（resolve最后执行）

    //Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。

    Promise.prototype.finally()
    promise
        .then(result => { })
        .catch(error => { })
        .finally(() => { });
    // 上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。

    //------Promise.all()------
    //Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。
    const promise = Promise.all([p1, p2, p3])
    //只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。
    //只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。
    // 生成一个Promise对象的数组  如下例子
    const promises = [2, 3, 5, 7, 11, 13].map(function (id) {
        return getJSON('/post/' + id + ".json");
    });
    Promise.all(promises).then(function (posts) {
        // ...
    }).catch(function (reason) {
        // ...
    });
    //注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法
    const p1 = new Promise((resolve, reject) => {
        resolve('hello');
    })
        .then(result => result)
        .catch(e => e);

    const p2 = new Promise((resolve, reject) => {
        throw new Error('报错了');
    })
        .then(result => result)
        .catch(e => e);

    Promise.all([p1, p2])
        .then(result => console.log(result))
        .catch(e => console.log(e));
    // ["hello", Error: 报错了]
    //上面代码中，p1会resolved，p2首先会rejected，但是p2有自己的catch方法，该方法返回的是一个新的Promise 实例p2指向的实际上是这个实例
    //该实例执行完catch方法后，也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved，
    //因此会调用then方法指定的回调函数，而不会调用catch方法指定的回调函数。
    const p1 = new Promise((resolve, reject) => {
        resolve('hello');
    })
        .then(result => result);

    const p2 = new Promise((resolve, reject) => {
        throw new Error('报错了');
    })
        .then(result => result);

    Promise.all([p1, p2])
        .then(result => console.log(result))
        .catch(e => console.log(e));
    // Error: 报错了

    //------Promise.race()------
    const p = Promise.race([p1, p2, p3]);
    //上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。
    //下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为reject，否则变为resolve。
    const p = Promise.race([
        fetch('/resource-that-may-take-a-while'),
        new Promise(function (resolve, reject) {
            setTimeout(() => reject(new Error('request timeout')), 5000)
        })
    ]);
    p
        .then(console.log)
        .catch(console.error);

    //------Promise.allSettled()------
    //只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束。
    const promises = [
        fetch('/api-1'),
        fetch('/api-2'),
        fetch('/api-3'),
    ];
    await Promise.allSettled(promises);
    removeLoadingIndicator();
    const resolved = Promise.resolve(42);
    const rejected = Promise.reject(-1);
    const allSettledPromise = Promise.allSettled([resolved, rejected]);
    allSettledPromise.then(function (results) {
        console.log(results);
    });
    // [
    //    { status: 'fulfilled', value: 42 },
    //    { status: 'rejected', reason: -1 }
    // ]

    const promises = [fetch('index.html'), fetch('https://does-not-exist/')];
    const results = await Promise.allSettled(promises);
    // 过滤出成功的请求
    const successfulPromises = results.filter(p => p.status === 'fulfilled');
    // 过滤出失败的请求，并输出原因
    const errors = results
        .filter(p => p.status === 'rejected')
        .map(p => p.reason);

    // 有时候，我们不关心异步操作的结果，只关心这些操作有没有结束。这时，Promise.allSettled()方法就很有用
    const urls = [ /* ... */];
    const requests = urls.map(x => fetch(x));

    try {
        await Promise.all(requests);
        console.log('所有请求都成功。');
    } catch {
        console.log('至少一个请求失败，其他请求可能还没结束。');
    }

    //------Promise.any() ------  只是一个提案

    //------Promise.try()------   只是一个提案


</script>

</html>